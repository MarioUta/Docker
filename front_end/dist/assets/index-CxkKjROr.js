(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const n of r)if(n.type==="childList")for(const o of n.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const n={};return r.integrity&&(n.integrity=r.integrity),r.referrerPolicy&&(n.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?n.credentials="include":r.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(r){if(r.ep)return;r.ep=!0;const n=e(r);fetch(r.href,n)}})();var ft={exports:{}},Lt;function de(){if(Lt)return ft.exports;Lt=1;var s=typeof Reflect=="object"?Reflect:null,t=s&&typeof s.apply=="function"?s.apply:function(g,w,v){return Function.prototype.apply.call(g,w,v)},e;s&&typeof s.ownKeys=="function"?e=s.ownKeys:Object.getOwnPropertySymbols?e=function(g){return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g))}:e=function(g){return Object.getOwnPropertyNames(g)};function i(y){console&&console.warn&&console.warn(y)}var r=Number.isNaN||function(g){return g!==g};function n(){n.init.call(this)}ft.exports=n,ft.exports.once=M,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._eventsCount=0,n.prototype._maxListeners=void 0;var o=10;function u(y){if(typeof y!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof y)}Object.defineProperty(n,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(y){if(typeof y!="number"||y<0||r(y))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+y+".");o=y}}),n.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},n.prototype.setMaxListeners=function(g){if(typeof g!="number"||g<0||r(g))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+g+".");return this._maxListeners=g,this};function d(y){return y._maxListeners===void 0?n.defaultMaxListeners:y._maxListeners}n.prototype.getMaxListeners=function(){return d(this)},n.prototype.emit=function(g){for(var w=[],v=1;v<arguments.length;v++)w.push(arguments[v]);var _=g==="error",L=this._events;if(L!==void 0)_=_&&L.error===void 0;else if(!_)return!1;if(_){var k;if(w.length>0&&(k=w[0]),k instanceof Error)throw k;var O=new Error("Unhandled error."+(k?" ("+k.message+")":""));throw O.context=k,O}var l=L[g];if(l===void 0)return!1;if(typeof l=="function")t(l,this,w);else for(var p=l.length,x=A(l,p),v=0;v<p;++v)t(x[v],this,w);return!0};function a(y,g,w,v){var _,L,k;if(u(w),L=y._events,L===void 0?(L=y._events=Object.create(null),y._eventsCount=0):(L.newListener!==void 0&&(y.emit("newListener",g,w.listener?w.listener:w),L=y._events),k=L[g]),k===void 0)k=L[g]=w,++y._eventsCount;else if(typeof k=="function"?k=L[g]=v?[w,k]:[k,w]:v?k.unshift(w):k.push(w),_=d(y),_>0&&k.length>_&&!k.warned){k.warned=!0;var O=new Error("Possible EventEmitter memory leak detected. "+k.length+" "+String(g)+" listeners added. Use emitter.setMaxListeners() to increase limit");O.name="MaxListenersExceededWarning",O.emitter=y,O.type=g,O.count=k.length,i(O)}return y}n.prototype.addListener=function(g,w){return a(this,g,w,!1)},n.prototype.on=n.prototype.addListener,n.prototype.prependListener=function(g,w){return a(this,g,w,!0)};function c(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function h(y,g,w){var v={fired:!1,wrapFn:void 0,target:y,type:g,listener:w},_=c.bind(v);return _.listener=w,v.wrapFn=_,_}n.prototype.once=function(g,w){return u(w),this.on(g,h(this,g,w)),this},n.prototype.prependOnceListener=function(g,w){return u(w),this.prependListener(g,h(this,g,w)),this},n.prototype.removeListener=function(g,w){var v,_,L,k,O;if(u(w),_=this._events,_===void 0)return this;if(v=_[g],v===void 0)return this;if(v===w||v.listener===w)--this._eventsCount===0?this._events=Object.create(null):(delete _[g],_.removeListener&&this.emit("removeListener",g,v.listener||w));else if(typeof v!="function"){for(L=-1,k=v.length-1;k>=0;k--)if(v[k]===w||v[k].listener===w){O=v[k].listener,L=k;break}if(L<0)return this;L===0?v.shift():$(v,L),v.length===1&&(_[g]=v[0]),_.removeListener!==void 0&&this.emit("removeListener",g,O||w)}return this},n.prototype.off=n.prototype.removeListener,n.prototype.removeAllListeners=function(g){var w,v,_;if(v=this._events,v===void 0)return this;if(v.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):v[g]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete v[g]),this;if(arguments.length===0){var L=Object.keys(v),k;for(_=0;_<L.length;++_)k=L[_],k!=="removeListener"&&this.removeAllListeners(k);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(w=v[g],typeof w=="function")this.removeListener(g,w);else if(w!==void 0)for(_=w.length-1;_>=0;_--)this.removeListener(g,w[_]);return this};function f(y,g,w){var v=y._events;if(v===void 0)return[];var _=v[g];return _===void 0?[]:typeof _=="function"?w?[_.listener||_]:[_]:w?S(_):A(_,_.length)}n.prototype.listeners=function(g){return f(this,g,!0)},n.prototype.rawListeners=function(g){return f(this,g,!1)},n.listenerCount=function(y,g){return typeof y.listenerCount=="function"?y.listenerCount(g):b.call(y,g)},n.prototype.listenerCount=b;function b(y){var g=this._events;if(g!==void 0){var w=g[y];if(typeof w=="function")return 1;if(w!==void 0)return w.length}return 0}n.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]};function A(y,g){for(var w=new Array(g),v=0;v<g;++v)w[v]=y[v];return w}function $(y,g){for(;g+1<y.length;g++)y[g]=y[g+1];y.pop()}function S(y){for(var g=new Array(y.length),w=0;w<g.length;++w)g[w]=y[w].listener||y[w];return g}function M(y,g){return new Promise(function(w,v){function _(k){y.removeListener(g,L),v(k)}function L(){typeof y.removeListener=="function"&&y.removeListener("error",_),w([].slice.call(arguments))}W(y,g,L,{once:!0}),g!=="error"&&C(y,_,{once:!0})})}function C(y,g,w){typeof y.on=="function"&&W(y,"error",g,w)}function W(y,g,w,v){if(typeof y.on=="function")v.once?y.once(g,w):y.on(g,w);else if(typeof y.addEventListener=="function")y.addEventListener(g,function _(L){v.once&&y.removeEventListener(g,_),w(L)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof y)}return ft.exports}var he=de();function ce(){const s=arguments[0];for(let t=1,e=arguments.length;t<e;t++)if(arguments[t])for(const i in arguments[t])s[i]=arguments[t][i];return s}let j=ce;typeof Object.assign=="function"&&(j=Object.assign);function X(s,t,e,i){const r=s._nodes.get(t);let n=null;return r&&(i==="mixed"?n=r.out&&r.out[e]||r.undirected&&r.undirected[e]:i==="directed"?n=r.out&&r.out[e]:n=r.undirected&&r.undirected[e]),n}function F(s){return typeof s=="object"&&s!==null}function qt(s){let t;for(t in s)return!1;return!0}function H(s,t,e){Object.defineProperty(s,t,{enumerable:!1,configurable:!1,writable:!0,value:e})}function Z(s,t,e){const i={enumerable:!0,configurable:!0};typeof e=="function"?i.get=e:(i.value=e,i.writable=!1),Object.defineProperty(s,t,i)}function Tt(s){return!(!F(s)||s.attributes&&!Array.isArray(s.attributes))}function fe(){let s=Math.floor(Math.random()*256)&255;return()=>s++}function Q(){const s=arguments;let t=null,e=-1;return{[Symbol.iterator](){return this},next(){let i=null;do{if(t===null){if(e++,e>=s.length)return{done:!0};t=s[e][Symbol.iterator]()}if(i=t.next(),i.done){t=null;continue}break}while(!0);return i}}}function ot(){return{[Symbol.iterator](){return this},next(){return{done:!0}}}}class Gt extends Error{constructor(t){super(),this.name="GraphError",this.message=t}}class E extends Gt{constructor(t){super(t),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,E.prototype.constructor)}}class m extends Gt{constructor(t){super(t),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,m.prototype.constructor)}}class G extends Gt{constructor(t){super(t),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G.prototype.constructor)}}function Vt(s,t){this.key=s,this.attributes=t,this.clear()}Vt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function Yt(s,t){this.key=s,this.attributes=t,this.clear()}Yt.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function Ht(s,t){this.key=s,this.attributes=t,this.clear()}Ht.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function at(s,t,e,i,r){this.key=t,this.attributes=r,this.undirected=s,this.source=e,this.target=i}at.prototype.attach=function(){let s="out",t="in";this.undirected&&(s=t="undirected");const e=this.source.key,i=this.target.key;this.source[s][i]=this,!(this.undirected&&e===i)&&(this.target[t][e]=this)};at.prototype.attachMulti=function(){let s="out",t="in";const e=this.source.key,i=this.target.key;this.undirected&&(s=t="undirected");const r=this.source[s],n=r[i];if(typeof n>"u"){r[i]=this,this.undirected&&e===i||(this.target[t][e]=this);return}n.previous=this,this.next=n,r[i]=this,this.target[t][e]=this};at.prototype.detach=function(){const s=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),delete this.source[e][t],delete this.target[i][s]};at.prototype.detachMulti=function(){const s=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[e][t],delete this.target[i][s]):(this.next.previous=void 0,this.source[e][t]=this.next,this.target[i][s]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const Xt=0,Zt=1,le=2,Jt=3;function tt(s,t,e,i,r,n,o){let u,d,a,c;if(i=""+i,e===Xt){if(u=s._nodes.get(i),!u)throw new m(`Graph.${t}: could not find the "${i}" node in the graph.`);a=r,c=n}else if(e===Jt){if(r=""+r,d=s._edges.get(r),!d)throw new m(`Graph.${t}: could not find the "${r}" edge in the graph.`);const h=d.source.key,f=d.target.key;if(i===h)u=d.target;else if(i===f)u=d.source;else throw new m(`Graph.${t}: the "${i}" node is not attached to the "${r}" edge (${h}, ${f}).`);a=n,c=o}else{if(d=s._edges.get(i),!d)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`);e===Zt?u=d.source:u=d.target,a=r,c=n}return[u,a,c]}function pe(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);return o.attributes[u]}}function ge(s,t,e){s.prototype[t]=function(i,r){const[n]=tt(this,t,e,i,r);return n.attributes}}function ye(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);return o.attributes.hasOwnProperty(u)}}function we(s,t,e){s.prototype[t]=function(i,r,n,o){const[u,d,a]=tt(this,t,e,i,r,n,o);return u.attributes[d]=a,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function me(s,t,e){s.prototype[t]=function(i,r,n,o){const[u,d,a]=tt(this,t,e,i,r,n,o);if(typeof a!="function")throw new E(`Graph.${t}: updater should be a function.`);const c=u.attributes,h=a(c[d]);return c[d]=h,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:d}),this}}function be(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);return delete o.attributes[u],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:u}),this}}function Ee(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);if(!F(u))throw new E(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=u,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function ve(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);if(!F(u))throw new E(`Graph.${t}: provided attributes are not a plain object.`);return j(o.attributes,u),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:u}),this}}function Ae(s,t,e){s.prototype[t]=function(i,r,n){const[o,u]=tt(this,t,e,i,r,n);if(typeof u!="function")throw new E(`Graph.${t}: provided updater is not a function.`);return o.attributes=u(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const _e=[{name:s=>`get${s}Attribute`,attacher:pe},{name:s=>`get${s}Attributes`,attacher:ge},{name:s=>`has${s}Attribute`,attacher:ye},{name:s=>`set${s}Attribute`,attacher:we},{name:s=>`update${s}Attribute`,attacher:me},{name:s=>`remove${s}Attribute`,attacher:be},{name:s=>`replace${s}Attributes`,attacher:Ee},{name:s=>`merge${s}Attributes`,attacher:ve},{name:s=>`update${s}Attributes`,attacher:Ae}];function xe(s){_e.forEach(function({name:t,attacher:e}){e(s,t("Node"),Xt),e(s,t("Source"),Zt),e(s,t("Target"),le),e(s,t("Opposite"),Jt)})}function $e(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return n.attributes[r]}}function Ge(s,t,e){s.prototype[t]=function(i){let r;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const n=""+i,o=""+arguments[1];if(r=X(this,n,o,e),!r)throw new m(`Graph.${t}: could not find an edge for the given path ("${n}" - "${o}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,r=this._edges.get(i),!r)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return r.attributes}}function De(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return n.attributes.hasOwnProperty(r)}}function ke(s,t,e){s.prototype[t]=function(i,r,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+i,d=""+r;if(r=arguments[2],n=arguments[3],o=X(this,u,d,e),!o)throw new m(`Graph.${t}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return o.attributes[r]=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}function Ne(s,t,e){s.prototype[t]=function(i,r,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const u=""+i,d=""+r;if(r=arguments[2],n=arguments[3],o=X(this,u,d,e),!o)throw new m(`Graph.${t}: could not find an edge for the given path ("${u}" - "${d}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof n!="function")throw new E(`Graph.${t}: updater should be a function.`);return o.attributes[r]=n(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}function Se(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return delete n.attributes[r],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:r}),this}}function Le(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!F(r))throw new E(`Graph.${t}: provided attributes are not a plain object.`);return n.attributes=r,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}function Te(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!F(r))throw new E(`Graph.${t}: provided attributes are not a plain object.`);return j(n.attributes,r),this.emit("edgeAttributesUpdated",{key:n.key,type:"merge",attributes:n.attributes,data:r}),this}}function Ue(s,t,e){s.prototype[t]=function(i,r){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new G(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new G(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,u=""+r;if(r=arguments[2],n=X(this,o,u,e),!n)throw new m(`Graph.${t}: could not find an edge for the given path ("${o}" - "${u}").`)}else{if(e!=="mixed")throw new G(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new m(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof r!="function")throw new E(`Graph.${t}: provided updater is not a function.`);return n.attributes=r(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}const Me=[{name:s=>`get${s}Attribute`,attacher:$e},{name:s=>`get${s}Attributes`,attacher:Ge},{name:s=>`has${s}Attribute`,attacher:De},{name:s=>`set${s}Attribute`,attacher:ke},{name:s=>`update${s}Attribute`,attacher:Ne},{name:s=>`remove${s}Attribute`,attacher:Se},{name:s=>`replace${s}Attributes`,attacher:Le},{name:s=>`merge${s}Attributes`,attacher:Te},{name:s=>`update${s}Attributes`,attacher:Ue}];function Ie(s){Me.forEach(function({name:t,attacher:e}){e(s,t("Edge"),"mixed"),e(s,t("DirectedEdge"),"directed"),e(s,t("UndirectedEdge"),"undirected")})}const Oe=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function ze(s,t,e,i){let r=!1;for(const n in t){if(n===i)continue;const o=t[n];if(r=e(o.key,o.attributes,o.source.key,o.target.key,o.source.attributes,o.target.attributes,o.undirected),s&&r)return o.key}}function Ce(s,t,e,i){let r,n,o,u=!1;for(const d in t)if(d!==i){r=t[d];do{if(n=r.source,o=r.target,u=e(r.key,r.attributes,n.key,o.key,n.attributes,o.attributes,r.undirected),s&&u)return r.key;r=r.next}while(r!==void 0)}}function yt(s,t){const e=Object.keys(s),i=e.length;let r,n=0;return{[Symbol.iterator](){return this},next(){do if(r)r=r.next;else{if(n>=i)return{done:!0};const o=e[n++];if(o===t){r=void 0;continue}r=s[o]}while(!r);return{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}}}}}function Pe(s,t,e,i){const r=t[e];if(!r)return;const n=r.source,o=r.target;if(i(r.key,r.attributes,n.key,o.key,n.attributes,o.attributes,r.undirected)&&s)return r.key}function Re(s,t,e,i){let r=t[e];if(!r)return;let n=!1;do{if(n=i(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),s&&n)return r.key;r=r.next}while(r!==void 0)}function wt(s,t){let e=s[t];if(e.next!==void 0)return{[Symbol.iterator](){return this},next(){if(!e)return{done:!0};const r={edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected};return e=e.next,{done:!1,value:r}}};let i=!1;return{[Symbol.iterator](){return this},next(){return i===!0?{done:!0}:(i=!0,{done:!1,value:{edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected}})}}}function We(s,t){if(s.size===0)return[];if(t==="mixed"||t===s.type)return Array.from(s._edges.keys());const e=t==="undirected"?s.undirectedSize:s.directedSize,i=new Array(e),r=t==="undirected",n=s._edges.values();let o=0,u,d;for(;u=n.next(),u.done!==!0;)d=u.value,d.undirected===r&&(i[o++]=d.key);return i}function Qt(s,t,e,i){if(t.size===0)return;const r=e!=="mixed"&&e!==t.type,n=e==="undirected";let o,u,d=!1;const a=t._edges.values();for(;o=a.next(),o.done!==!0;){if(u=o.value,r&&u.undirected!==n)continue;const{key:c,attributes:h,source:f,target:b}=u;if(d=i(c,h,f.key,b.key,f.attributes,b.attributes,u.undirected),s&&d)return c}}function je(s,t){if(s.size===0)return ot();const e=t!=="mixed"&&t!==s.type,i=t==="undirected",r=s._edges.values();return{[Symbol.iterator](){return this},next(){let n,o;for(;;){if(n=r.next(),n.done)return n;if(o=n.value,!(e&&o.undirected!==i))break}return{value:{edge:o.key,attributes:o.attributes,source:o.source.key,target:o.target.key,sourceAttributes:o.source.attributes,targetAttributes:o.target.attributes,undirected:o.undirected},done:!1}}}}function Dt(s,t,e,i,r,n){const o=t?Ce:ze;let u;if(e!=="undirected"&&(i!=="out"&&(u=o(s,r.in,n),s&&u)||i!=="in"&&(u=o(s,r.out,n,i?void 0:r.key),s&&u))||e!=="directed"&&(u=o(s,r.undirected,n),s&&u))return u}function Fe(s,t,e,i){const r=[];return Dt(!1,s,t,e,i,function(n){r.push(n)}),r}function Ke(s,t,e){let i=ot();return s!=="undirected"&&(t!=="out"&&typeof e.in<"u"&&(i=Q(i,yt(e.in))),t!=="in"&&typeof e.out<"u"&&(i=Q(i,yt(e.out,t?void 0:e.key)))),s!=="directed"&&typeof e.undirected<"u"&&(i=Q(i,yt(e.undirected))),i}function kt(s,t,e,i,r,n,o){const u=e?Re:Pe;let d;if(t!=="undirected"&&(typeof r.in<"u"&&i!=="out"&&(d=u(s,r.in,n,o),s&&d)||typeof r.out<"u"&&i!=="in"&&(i||r.key!==n)&&(d=u(s,r.out,n,o),s&&d))||t!=="directed"&&typeof r.undirected<"u"&&(d=u(s,r.undirected,n,o),s&&d))return d}function Be(s,t,e,i,r){const n=[];return kt(!1,s,t,e,i,r,function(o){n.push(o)}),n}function qe(s,t,e,i){let r=ot();return s!=="undirected"&&(typeof e.in<"u"&&t!=="out"&&i in e.in&&(r=Q(r,wt(e.in,i))),typeof e.out<"u"&&t!=="in"&&i in e.out&&(t||e.key!==i)&&(r=Q(r,wt(e.out,i)))),s!=="directed"&&typeof e.undirected<"u"&&i in e.undirected&&(r=Q(r,wt(e.undirected,i))),r}function Ve(s,t){const{name:e,type:i,direction:r}=t;s.prototype[e]=function(n,o){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];if(!arguments.length)return We(this,i);if(arguments.length===1){n=""+n;const u=this._nodes.get(n);if(typeof u>"u")throw new m(`Graph.${e}: could not find the "${n}" node in the graph.`);return Fe(this.multi,i==="mixed"?this.type:i,r,u)}if(arguments.length===2){n=""+n,o=""+o;const u=this._nodes.get(n);if(!u)throw new m(`Graph.${e}:  could not find the "${n}" source node in the graph.`);if(!this._nodes.has(o))throw new m(`Graph.${e}:  could not find the "${o}" target node in the graph.`);return Be(i,this.multi,r,u,o)}throw new E(`Graph.${e}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Ye(s,t){const{name:e,type:i,direction:r}=t,n="forEach"+e[0].toUpperCase()+e.slice(1,-1);s.prototype[n]=function(a,c,h){if(!(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)){if(arguments.length===1)return h=a,Qt(!1,this,i,h);if(arguments.length===2){a=""+a,h=c;const f=this._nodes.get(a);if(typeof f>"u")throw new m(`Graph.${n}: could not find the "${a}" node in the graph.`);return Dt(!1,this.multi,i==="mixed"?this.type:i,r,f,h)}if(arguments.length===3){a=""+a,c=""+c;const f=this._nodes.get(a);if(!f)throw new m(`Graph.${n}:  could not find the "${a}" source node in the graph.`);if(!this._nodes.has(c))throw new m(`Graph.${n}:  could not find the "${c}" target node in the graph.`);return kt(!1,i,this.multi,r,f,c,h)}throw new E(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const o="map"+e[0].toUpperCase()+e.slice(1);s.prototype[o]=function(){const a=Array.prototype.slice.call(arguments),c=a.pop();let h;if(a.length===0){let f=0;i!=="directed"&&(f+=this.undirectedSize),i!=="undirected"&&(f+=this.directedSize),h=new Array(f);let b=0;a.push((A,$,S,M,C,W,y)=>{h[b++]=c(A,$,S,M,C,W,y)})}else h=[],a.push((f,b,A,$,S,M,C)=>{h.push(c(f,b,A,$,S,M,C))});return this[n].apply(this,a),h};const u="filter"+e[0].toUpperCase()+e.slice(1);s.prototype[u]=function(){const a=Array.prototype.slice.call(arguments),c=a.pop(),h=[];return a.push((f,b,A,$,S,M,C)=>{c(f,b,A,$,S,M,C)&&h.push(f)}),this[n].apply(this,a),h};const d="reduce"+e[0].toUpperCase()+e.slice(1);s.prototype[d]=function(){let a=Array.prototype.slice.call(arguments);if(a.length<2||a.length>4)throw new E(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${a.length}).`);if(typeof a[a.length-1]=="function"&&typeof a[a.length-2]!="function")throw new E(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let c,h;a.length===2?(c=a[0],h=a[1],a=[]):a.length===3?(c=a[1],h=a[2],a=[a[0]]):a.length===4&&(c=a[2],h=a[3],a=[a[0],a[1]]);let f=h;return a.push((b,A,$,S,M,C,W)=>{f=c(f,b,A,$,S,M,C,W)}),this[n].apply(this,a),f}}function He(s,t){const{name:e,type:i,direction:r}=t,n="find"+e[0].toUpperCase()+e.slice(1,-1);s.prototype[n]=function(d,a,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return!1;if(arguments.length===1)return c=d,Qt(!0,this,i,c);if(arguments.length===2){d=""+d,c=a;const h=this._nodes.get(d);if(typeof h>"u")throw new m(`Graph.${n}: could not find the "${d}" node in the graph.`);return Dt(!0,this.multi,i==="mixed"?this.type:i,r,h,c)}if(arguments.length===3){d=""+d,a=""+a;const h=this._nodes.get(d);if(!h)throw new m(`Graph.${n}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(a))throw new m(`Graph.${n}:  could not find the "${a}" target node in the graph.`);return kt(!0,i,this.multi,r,h,a,c)}throw new E(`Graph.${n}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const o="some"+e[0].toUpperCase()+e.slice(1,-1);s.prototype[o]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((h,f,b,A,$,S,M)=>a(h,f,b,A,$,S,M)),!!this[n].apply(this,d)};const u="every"+e[0].toUpperCase()+e.slice(1,-1);s.prototype[u]=function(){const d=Array.prototype.slice.call(arguments),a=d.pop();return d.push((h,f,b,A,$,S,M)=>!a(h,f,b,A,$,S,M)),!this[n].apply(this,d)}}function Xe(s,t){const{name:e,type:i,direction:r}=t,n=e.slice(0,-1)+"Entries";s.prototype[n]=function(o,u){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return ot();if(!arguments.length)return je(this,i);if(arguments.length===1){o=""+o;const d=this._nodes.get(o);if(!d)throw new m(`Graph.${n}: could not find the "${o}" node in the graph.`);return Ke(i,r,d)}if(arguments.length===2){o=""+o,u=""+u;const d=this._nodes.get(o);if(!d)throw new m(`Graph.${n}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(u))throw new m(`Graph.${n}:  could not find the "${u}" target node in the graph.`);return qe(i,r,d,u)}throw new E(`Graph.${n}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Ze(s){Oe.forEach(t=>{Ve(s,t),Ye(s,t),He(s,t),Xe(s,t)})}const Je=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function gt(){this.A=null,this.B=null}gt.prototype.wrap=function(s){this.A===null?this.A=s:this.B===null&&(this.B=s)};gt.prototype.has=function(s){return this.A!==null&&s in this.A||this.B!==null&&s in this.B};function dt(s,t,e,i,r){for(const n in i){const o=i[n],u=o.source,d=o.target,a=u===e?d:u;if(t&&t.has(a.key))continue;const c=r(a.key,a.attributes);if(s&&c)return a.key}}function Nt(s,t,e,i,r){if(t!=="mixed"){if(t==="undirected")return dt(s,null,i,i.undirected,r);if(typeof e=="string")return dt(s,null,i,i[e],r)}const n=new gt;let o;if(t!=="undirected"){if(e!=="out"){if(o=dt(s,null,i,i.in,r),s&&o)return o;n.wrap(i.in)}if(e!=="in"){if(o=dt(s,n,i,i.out,r),s&&o)return o;n.wrap(i.out)}}if(t!=="directed"&&(o=dt(s,n,i,i.undirected,r),s&&o))return o}function Qe(s,t,e){if(s!=="mixed"){if(s==="undirected")return Object.keys(e.undirected);if(typeof t=="string")return Object.keys(e[t])}const i=[];return Nt(!1,s,t,e,function(r){i.push(r)}),i}function ht(s,t,e){const i=Object.keys(e),r=i.length;let n=0;return{[Symbol.iterator](){return this},next(){let o=null;do{if(n>=r)return s&&s.wrap(e),{done:!0};const u=e[i[n++]],d=u.source,a=u.target;if(o=d===t?a:d,s&&s.has(o.key)){o=null;continue}}while(o===null);return{done:!1,value:{neighbor:o.key,attributes:o.attributes}}}}}function ti(s,t,e){if(s!=="mixed"){if(s==="undirected")return ht(null,e,e.undirected);if(typeof t=="string")return ht(null,e,e[t])}let i=ot();const r=new gt;return s!=="undirected"&&(t!=="out"&&(i=Q(i,ht(r,e,e.in))),t!=="in"&&(i=Q(i,ht(r,e,e.out)))),s!=="directed"&&(i=Q(i,ht(r,e,e.undirected))),i}function ei(s,t){const{name:e,type:i,direction:r}=t;s.prototype[e]=function(n){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];n=""+n;const o=this._nodes.get(n);if(typeof o>"u")throw new m(`Graph.${e}: could not find the "${n}" node in the graph.`);return Qe(i==="mixed"?this.type:i,r,o)}}function ii(s,t){const{name:e,type:i,direction:r}=t,n="forEach"+e[0].toUpperCase()+e.slice(1,-1);s.prototype[n]=function(a,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;a=""+a;const h=this._nodes.get(a);if(typeof h>"u")throw new m(`Graph.${n}: could not find the "${a}" node in the graph.`);Nt(!1,i==="mixed"?this.type:i,r,h,c)};const o="map"+e[0].toUpperCase()+e.slice(1);s.prototype[o]=function(a,c){const h=[];return this[n](a,(f,b)=>{h.push(c(f,b))}),h};const u="filter"+e[0].toUpperCase()+e.slice(1);s.prototype[u]=function(a,c){const h=[];return this[n](a,(f,b)=>{c(f,b)&&h.push(f)}),h};const d="reduce"+e[0].toUpperCase()+e.slice(1);s.prototype[d]=function(a,c,h){if(arguments.length<3)throw new E(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let f=h;return this[n](a,(b,A)=>{f=c(f,b,A)}),f}}function ri(s,t){const{name:e,type:i,direction:r}=t,n=e[0].toUpperCase()+e.slice(1,-1),o="find"+n;s.prototype[o]=function(a,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;a=""+a;const h=this._nodes.get(a);if(typeof h>"u")throw new m(`Graph.${o}: could not find the "${a}" node in the graph.`);return Nt(!0,i==="mixed"?this.type:i,r,h,c)};const u="some"+n;s.prototype[u]=function(a,c){return!!this[o](a,c)};const d="every"+n;s.prototype[d]=function(a,c){return!this[o](a,(f,b)=>!c(f,b))}}function ni(s,t){const{name:e,type:i,direction:r}=t,n=e.slice(0,-1)+"Entries";s.prototype[n]=function(o){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return ot();o=""+o;const u=this._nodes.get(o);if(typeof u>"u")throw new m(`Graph.${n}: could not find the "${o}" node in the graph.`);return ti(i==="mixed"?this.type:i,r,u)}}function si(s){Je.forEach(t=>{ei(s,t),ii(s,t),ri(s,t),ni(s,t)})}function lt(s,t,e,i,r){const n=i._nodes.values(),o=i.type;let u,d,a,c,h,f;for(;u=n.next(),u.done!==!0;){let b=!1;if(d=u.value,o!=="undirected"){c=d.out;for(a in c){h=c[a];do f=h.target,b=!0,r(d.key,f.key,d.attributes,f.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}if(o!=="directed"){c=d.undirected;for(a in c)if(!(t&&d.key>a)){h=c[a];do f=h.target,f.key!==a&&(f=h.source),b=!0,r(d.key,f.key,d.attributes,f.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}e&&!b&&r(d.key,null,d.attributes,null,null,null,null)}}function oi(s,t){const e={key:s};return qt(t.attributes)||(e.attributes=j({},t.attributes)),e}function ai(s,t,e){const i={key:t,source:e.source.key,target:e.target.key};return qt(e.attributes)||(i.attributes=j({},e.attributes)),s==="mixed"&&e.undirected&&(i.undirected=!0),i}function ui(s){if(!F(s))throw new E('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in s))throw new E("Graph.import: serialized node is missing its key.");if("attributes"in s&&(!F(s.attributes)||s.attributes===null))throw new E("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function di(s){if(!F(s))throw new E('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in s))throw new E("Graph.import: serialized edge is missing its source.");if(!("target"in s))throw new E("Graph.import: serialized edge is missing its target.");if("attributes"in s&&(!F(s.attributes)||s.attributes===null))throw new E("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in s&&typeof s.undirected!="boolean")throw new E("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const hi=fe(),ci=new Set(["directed","undirected","mixed"]),Ut=new Set(["domain","_events","_eventsCount","_maxListeners"]),fi=[{name:s=>`${s}Edge`,generateKey:!0},{name:s=>`${s}DirectedEdge`,generateKey:!0,type:"directed"},{name:s=>`${s}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:s=>`${s}EdgeWithKey`},{name:s=>`${s}DirectedEdgeWithKey`,type:"directed"},{name:s=>`${s}UndirectedEdgeWithKey`,type:"undirected"}],li={allowSelfLoops:!0,multi:!1,type:"mixed"};function pi(s,t,e){if(e&&!F(e))throw new E(`Graph.addNode: invalid attributes. Expecting an object but got "${e}"`);if(t=""+t,e=e||{},s._nodes.has(t))throw new G(`Graph.addNode: the "${t}" node already exist in the graph.`);const i=new s.NodeDataClass(t,e);return s._nodes.set(t,i),s.emit("nodeAdded",{key:t,attributes:e}),i}function Mt(s,t,e){const i=new s.NodeDataClass(t,e);return s._nodes.set(t,i),s.emit("nodeAdded",{key:t,attributes:e}),i}function te(s,t,e,i,r,n,o,u){if(!i&&s.type==="undirected")throw new G(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&s.type==="directed")throw new G(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(u&&!F(u))throw new E(`Graph.${t}: invalid attributes. Expecting an object but got "${u}"`);if(n=""+n,o=""+o,u=u||{},!s.allowSelfLoops&&n===o)throw new G(`Graph.${t}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=s._nodes.get(n),a=s._nodes.get(o);if(!d)throw new m(`Graph.${t}: source node "${n}" not found.`);if(!a)throw new m(`Graph.${t}: target node "${o}" not found.`);const c={key:null,undirected:i,source:n,target:o,attributes:u};if(e)r=s._edgeKeyGenerator();else if(r=""+r,s._edges.has(r))throw new G(`Graph.${t}: the "${r}" edge already exists in the graph.`);if(!s.multi&&(i?typeof d.undirected[o]<"u":typeof d.out[o]<"u"))throw new G(`Graph.${t}: an edge linking "${n}" to "${o}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const h=new at(i,r,d,a,u);s._edges.set(r,h);const f=n===o;return i?(d.undirectedDegree++,a.undirectedDegree++,f&&(d.undirectedLoops++,s._undirectedSelfLoopCount++)):(d.outDegree++,a.inDegree++,f&&(d.directedLoops++,s._directedSelfLoopCount++)),s.multi?h.attachMulti():h.attach(),i?s._undirectedSize++:s._directedSize++,c.key=r,s.emit("edgeAdded",c),r}function gi(s,t,e,i,r,n,o,u,d){if(!i&&s.type==="undirected")throw new G(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&s.type==="directed")throw new G(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(u){if(d){if(typeof u!="function")throw new E(`Graph.${t}: invalid updater function. Expecting a function but got "${u}"`)}else if(!F(u))throw new E(`Graph.${t}: invalid attributes. Expecting an object but got "${u}"`)}n=""+n,o=""+o;let a;if(d&&(a=u,u=void 0),!s.allowSelfLoops&&n===o)throw new G(`Graph.${t}: source & target are the same ("${n}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let c=s._nodes.get(n),h=s._nodes.get(o),f,b;if(!e&&(f=s._edges.get(r),f)){if((f.source.key!==n||f.target.key!==o)&&(!i||f.source.key!==o||f.target.key!==n))throw new G(`Graph.${t}: inconsistency detected when attempting to merge the "${r}" edge with "${n}" source & "${o}" target vs. ("${f.source.key}", "${f.target.key}").`);b=f}if(!b&&!s.multi&&c&&(b=i?c.undirected[o]:c.out[o]),b){const C=[b.key,!1,!1,!1];if(d?!a:!u)return C;if(d){const W=b.attributes;b.attributes=a(W),s.emit("edgeAttributesUpdated",{type:"replace",key:b.key,attributes:b.attributes})}else j(b.attributes,u),s.emit("edgeAttributesUpdated",{type:"merge",key:b.key,attributes:b.attributes,data:u});return C}u=u||{},d&&a&&(u=a(u));const A={key:null,undirected:i,source:n,target:o,attributes:u};if(e)r=s._edgeKeyGenerator();else if(r=""+r,s._edges.has(r))throw new G(`Graph.${t}: the "${r}" edge already exists in the graph.`);let $=!1,S=!1;c||(c=Mt(s,n,{}),$=!0,n===o&&(h=c,S=!0)),h||(h=Mt(s,o,{}),S=!0),f=new at(i,r,c,h,u),s._edges.set(r,f);const M=n===o;return i?(c.undirectedDegree++,h.undirectedDegree++,M&&(c.undirectedLoops++,s._undirectedSelfLoopCount++)):(c.outDegree++,h.inDegree++,M&&(c.directedLoops++,s._directedSelfLoopCount++)),s.multi?f.attachMulti():f.attach(),i?s._undirectedSize++:s._directedSize++,A.key=r,s.emit("edgeAdded",A),[r,!0,$,S]}function rt(s,t){s._edges.delete(t.key);const{source:e,target:i,attributes:r}=t,n=t.undirected,o=e===i;n?(e.undirectedDegree--,i.undirectedDegree--,o&&(e.undirectedLoops--,s._undirectedSelfLoopCount--)):(e.outDegree--,i.inDegree--,o&&(e.directedLoops--,s._directedSelfLoopCount--)),s.multi?t.detachMulti():t.detach(),n?s._undirectedSize--:s._directedSize--,s.emit("edgeDropped",{key:t.key,attributes:r,source:e.key,target:i.key,undirected:n})}class I extends he.EventEmitter{constructor(t){if(super(),t=j({},li,t),typeof t.multi!="boolean")throw new E(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${t.multi}".`);if(!ci.has(t.type))throw new E(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${t.type}".`);if(typeof t.allowSelfLoops!="boolean")throw new E(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${t.allowSelfLoops}".`);const e=t.type==="mixed"?Vt:t.type==="directed"?Yt:Ht;H(this,"NodeDataClass",e);const i="geid_"+hi()+"_";let r=0;const n=()=>{let o;do o=i+r++;while(this._edges.has(o));return o};H(this,"_attributes",{}),H(this,"_nodes",new Map),H(this,"_edges",new Map),H(this,"_directedSize",0),H(this,"_undirectedSize",0),H(this,"_directedSelfLoopCount",0),H(this,"_undirectedSelfLoopCount",0),H(this,"_edgeKeyGenerator",n),H(this,"_options",t),Ut.forEach(o=>H(this,o,this[o])),Z(this,"order",()=>this._nodes.size),Z(this,"size",()=>this._edges.size),Z(this,"directedSize",()=>this._directedSize),Z(this,"undirectedSize",()=>this._undirectedSize),Z(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),Z(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),Z(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),Z(this,"multi",this._options.multi),Z(this,"type",this._options.type),Z(this,"allowSelfLoops",this._options.allowSelfLoops),Z(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(t){return this._nodes.has(""+t)}hasDirectedEdge(t,e){if(this.type==="undirected")return!1;if(arguments.length===1){const i=""+t,r=this._edges.get(i);return!!r&&!r.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.out.hasOwnProperty(e):!1}throw new E(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(t,e){if(this.type==="directed")return!1;if(arguments.length===1){const i=""+t,r=this._edges.get(i);return!!r&&r.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.undirected.hasOwnProperty(e):!1}throw new E(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(t,e){if(arguments.length===1){const i=""+t;return this._edges.has(i)}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?typeof i.out<"u"&&i.out.hasOwnProperty(e)||typeof i.undirected<"u"&&i.undirected.hasOwnProperty(e):!1}throw new E(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(t,e){if(this.type==="undirected")return;if(t=""+t,e=""+e,this.multi)throw new G("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const i=this._nodes.get(t);if(!i)throw new m(`Graph.directedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new m(`Graph.directedEdge: could not find the "${e}" target node in the graph.`);const r=i.out&&i.out[e]||void 0;if(r)return r.key}undirectedEdge(t,e){if(this.type==="directed")return;if(t=""+t,e=""+e,this.multi)throw new G("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const i=this._nodes.get(t);if(!i)throw new m(`Graph.undirectedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new m(`Graph.undirectedEdge: could not find the "${e}" target node in the graph.`);const r=i.undirected&&i.undirected[e]||void 0;if(r)return r.key}edge(t,e){if(this.multi)throw new G("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.edge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new m(`Graph.edge: could not find the "${e}" target node in the graph.`);const r=i.out&&i.out[e]||i.undirected&&i.undirected[e]||void 0;if(r)return r.key}areDirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areDirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in||e in i.out}areOutNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areOutNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.out}areInNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areInNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in}areUndirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areUndirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="directed"?!1:e in i.undirected}areNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&(e in i.in||e in i.out)||this.type!=="directed"&&e in i.undirected}areInboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areInboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.in||this.type!=="directed"&&e in i.undirected}areOutboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new m(`Graph.areOutboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.out||this.type!=="directed"&&e in i.undirected}inDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.inDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree}outDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.outDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree}directedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.directedDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree}undirectedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.undirectedDegree: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree}inboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.inboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree),i}outboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.outboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.outDegree),i}degree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.degree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree),i}inDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.inDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree-e.directedLoops}outDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.outDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree-e.directedLoops}directedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.directedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree-e.directedLoops*2}undirectedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree-e.undirectedLoops*2}inboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,r=0;return this.type!=="directed"&&(i+=e.undirectedDegree,r+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree,r+=e.directedLoops),i-r}outboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,r=0;return this.type!=="directed"&&(i+=e.undirectedDegree,r+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.outDegree,r+=e.directedLoops),i-r}degreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.degreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,r=0;return this.type!=="directed"&&(i+=e.undirectedDegree,r+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree,r+=e.directedLoops*2),i-r}source(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.source: could not find the "${t}" edge in the graph.`);return e.source.key}target(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.target: could not find the "${t}" edge in the graph.`);return e.target.key}extremities(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.extremities: could not find the "${t}" edge in the graph.`);return[e.source.key,e.target.key]}opposite(t,e){t=""+t,e=""+e;const i=this._edges.get(e);if(!i)throw new m(`Graph.opposite: could not find the "${e}" edge in the graph.`);const r=i.source.key,n=i.target.key;if(t===r)return n;if(t===n)return r;throw new m(`Graph.opposite: the "${t}" node is not attached to the "${e}" edge (${r}, ${n}).`)}hasExtremity(t,e){t=""+t,e=""+e;const i=this._edges.get(t);if(!i)throw new m(`Graph.hasExtremity: could not find the "${t}" edge in the graph.`);return i.source.key===e||i.target.key===e}isUndirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.isUndirected: could not find the "${t}" edge in the graph.`);return e.undirected}isDirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.isDirected: could not find the "${t}" edge in the graph.`);return!e.undirected}isSelfLoop(t){t=""+t;const e=this._edges.get(t);if(!e)throw new m(`Graph.isSelfLoop: could not find the "${t}" edge in the graph.`);return e.source===e.target}addNode(t,e){return pi(this,t,e).key}mergeNode(t,e){if(e&&!F(e))throw new E(`Graph.mergeNode: invalid attributes. Expecting an object but got "${e}"`);t=""+t,e=e||{};let i=this._nodes.get(t);return i?(e&&(j(i.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:i.attributes,data:e})),[t,!1]):(i=new this.NodeDataClass(t,e),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])}updateNode(t,e){if(e&&typeof e!="function")throw new E(`Graph.updateNode: invalid updater function. Expecting a function but got "${e}"`);t=""+t;let i=this._nodes.get(t);if(i){if(e){const n=i.attributes;i.attributes=e(n),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:i.attributes})}return[t,!1]}const r=e?e({}):{};return i=new this.NodeDataClass(t,r),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:r}),[t,!0]}dropNode(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new m(`Graph.dropNode: could not find the "${t}" node in the graph.`);let i;if(this.type!=="undirected"){for(const r in e.out){i=e.out[r];do rt(this,i),i=i.next;while(i)}for(const r in e.in){i=e.in[r];do rt(this,i),i=i.next;while(i)}}if(this.type!=="directed")for(const r in e.undirected){i=e.undirected[r];do rt(this,i),i=i.next;while(i)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:e.attributes})}dropEdge(t){let e;if(arguments.length>1){const i=""+arguments[0],r=""+arguments[1];if(e=X(this,i,r,this.type),!e)throw new m(`Graph.dropEdge: could not find the "${i}" -> "${r}" edge in the graph.`)}else if(t=""+t,e=this._edges.get(t),!e)throw new m(`Graph.dropEdge: could not find the "${t}" edge in the graph.`);return rt(this,e),this}dropDirectedEdge(t,e){if(arguments.length<2)throw new G("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");t=""+t,e=""+e;const i=X(this,t,e,"directed");if(!i)throw new m(`Graph.dropDirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return rt(this,i),this}dropUndirectedEdge(t,e){if(arguments.length<2)throw new G("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=X(this,t,e,"undirected");if(!i)throw new m(`Graph.dropUndirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return rt(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const t=this._nodes.values();let e;for(;e=t.next(),e.done!==!0;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(t){return this._attributes[t]}getAttributes(){return this._attributes}hasAttribute(t){return this._attributes.hasOwnProperty(t)}setAttribute(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}updateAttribute(t,e){if(typeof e!="function")throw new E("Graph.updateAttribute: updater should be a function.");const i=this._attributes[t];return this._attributes[t]=e(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}removeAttribute(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this}replaceAttributes(t){if(!F(t))throw new E("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(t){if(!F(t))throw new E("Graph.mergeAttributes: provided attributes are not a plain object.");return j(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this}updateAttributes(t){if(typeof t!="function")throw new E("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(t,e){if(typeof t!="function")throw new E("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!Tt(e))throw new E("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._nodes.values();let r,n;for(;r=i.next(),r.done!==!0;)n=r.value,n.attributes=t(n.key,n.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})}updateEachEdgeAttributes(t,e){if(typeof t!="function")throw new E("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!Tt(e))throw new E("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._edges.values();let r,n,o,u;for(;r=i.next(),r.done!==!0;)n=r.value,o=n.source,u=n.target,n.attributes=t(n.key,n.attributes,o.key,u.key,o.attributes,u.attributes,n.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})}forEachAdjacencyEntry(t){if(typeof t!="function")throw new E("Graph.forEachAdjacencyEntry: expecting a callback.");lt(!1,!1,!1,this,t)}forEachAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new E("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");lt(!1,!1,!0,this,t)}forEachAssymetricAdjacencyEntry(t){if(typeof t!="function")throw new E("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");lt(!1,!0,!1,this,t)}forEachAssymetricAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new E("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");lt(!1,!0,!0,this,t)}nodes(){return Array.from(this._nodes.keys())}forEachNode(t){if(typeof t!="function")throw new E("Graph.forEachNode: expecting a callback.");const e=this._nodes.values();let i,r;for(;i=e.next(),i.done!==!0;)r=i.value,t(r.key,r.attributes)}findNode(t){if(typeof t!="function")throw new E("Graph.findNode: expecting a callback.");const e=this._nodes.values();let i,r;for(;i=e.next(),i.done!==!0;)if(r=i.value,t(r.key,r.attributes))return r.key}mapNodes(t){if(typeof t!="function")throw new E("Graph.mapNode: expecting a callback.");const e=this._nodes.values();let i,r;const n=new Array(this.order);let o=0;for(;i=e.next(),i.done!==!0;)r=i.value,n[o++]=t(r.key,r.attributes);return n}someNode(t){if(typeof t!="function")throw new E("Graph.someNode: expecting a callback.");const e=this._nodes.values();let i,r;for(;i=e.next(),i.done!==!0;)if(r=i.value,t(r.key,r.attributes))return!0;return!1}everyNode(t){if(typeof t!="function")throw new E("Graph.everyNode: expecting a callback.");const e=this._nodes.values();let i,r;for(;i=e.next(),i.done!==!0;)if(r=i.value,!t(r.key,r.attributes))return!1;return!0}filterNodes(t){if(typeof t!="function")throw new E("Graph.filterNodes: expecting a callback.");const e=this._nodes.values();let i,r;const n=[];for(;i=e.next(),i.done!==!0;)r=i.value,t(r.key,r.attributes)&&n.push(r.key);return n}reduceNodes(t,e){if(typeof t!="function")throw new E("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new E("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let i=e;const r=this._nodes.values();let n,o;for(;n=r.next(),n.done!==!0;)o=n.value,i=t(i,o.key,o.attributes);return i}nodeEntries(){const t=this._nodes.values();return{[Symbol.iterator](){return this},next(){const e=t.next();if(e.done)return e;const i=e.value;return{value:{node:i.key,attributes:i.attributes},done:!1}}}}export(){const t=new Array(this._nodes.size);let e=0;this._nodes.forEach((r,n)=>{t[e++]=oi(n,r)});const i=new Array(this._edges.size);return e=0,this._edges.forEach((r,n)=>{i[e++]=ai(this.type,n,r)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:i}}import(t,e=!1){if(t instanceof I)return t.forEachNode((d,a)=>{e?this.mergeNode(d,a):this.addNode(d,a)}),t.forEachEdge((d,a,c,h,f,b,A)=>{e?A?this.mergeUndirectedEdgeWithKey(d,c,h,a):this.mergeDirectedEdgeWithKey(d,c,h,a):A?this.addUndirectedEdgeWithKey(d,c,h,a):this.addDirectedEdgeWithKey(d,c,h,a)}),this;if(!F(t))throw new E("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!F(t.attributes))throw new E("Graph.import: invalid attributes. Expecting a plain object.");e?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}let i,r,n,o,u;if(t.nodes){if(n=t.nodes,!Array.isArray(n))throw new E("Graph.import: invalid nodes. Expecting an array.");for(i=0,r=n.length;i<r;i++){o=n[i],ui(o);const{key:d,attributes:a}=o;e?this.mergeNode(d,a):this.addNode(d,a)}}if(t.edges){let d=!1;if(this.type==="undirected"&&(d=!0),n=t.edges,!Array.isArray(n))throw new E("Graph.import: invalid edges. Expecting an array.");for(i=0,r=n.length;i<r;i++){u=n[i],di(u);const{source:a,target:c,attributes:h,undirected:f=d}=u;let b;"key"in u?(b=e?f?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:f?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,b.call(this,u.key,a,c,h)):(b=e?f?this.mergeUndirectedEdge:this.mergeDirectedEdge:f?this.addUndirectedEdge:this.addDirectedEdge,b.call(this,a,c,h))}}return this}nullCopy(t){const e=new I(j({},this._options,t));return e.replaceAttributes(j({},this.getAttributes())),e}emptyCopy(t){const e=this.nullCopy(t);return this._nodes.forEach((i,r)=>{const n=j({},i.attributes);i=new e.NodeDataClass(r,n),e._nodes.set(r,i)}),e}copy(t){if(t=t||{},typeof t.type=="string"&&t.type!==this.type&&t.type!=="mixed")throw new G(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${t.type}" because this would mean losing information about the current graph.`);if(typeof t.multi=="boolean"&&t.multi!==this.multi&&t.multi!==!0)throw new G("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof t.allowSelfLoops=="boolean"&&t.allowSelfLoops!==this.allowSelfLoops&&t.allowSelfLoops!==!0)throw new G("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const e=this.emptyCopy(t),i=this._edges.values();let r,n;for(;r=i.next(),r.done!==!0;)n=r.value,te(e,"copy",!1,n.undirected,n.key,n.source.key,n.target.key,j({},n.attributes));return e}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const t={};this._nodes.forEach((n,o)=>{t[o]=n.attributes});const e={},i={};this._edges.forEach((n,o)=>{const u=n.undirected?"--":"->";let d="",a=n.source.key,c=n.target.key,h;n.undirected&&a>c&&(h=a,a=c,c=h);const f=`(${a})${u}(${c})`;o.startsWith("geid_")?this.multi&&(typeof i[f]>"u"?i[f]=0:i[f]++,d+=`${i[f]}. `):d+=`[${o}]: `,d+=f,e[d]=n.attributes});const r={};for(const n in this)this.hasOwnProperty(n)&&!Ut.has(n)&&typeof this[n]!="function"&&typeof n!="symbol"&&(r[n]=this[n]);return r.attributes=this._attributes,r.nodes=t,r.edges=e,H(r,"constructor",this.constructor),r}}typeof Symbol<"u"&&(I.prototype[Symbol.for("nodejs.util.inspect.custom")]=I.prototype.inspect);fi.forEach(s=>{["add","merge","update"].forEach(t=>{const e=s.name(t),i=t==="add"?te:gi;s.generateKey?I.prototype[e]=function(r,n,o){return i(this,e,!0,(s.type||this.type)==="undirected",null,r,n,o,t==="update")}:I.prototype[e]=function(r,n,o,u){return i(this,e,!1,(s.type||this.type)==="undirected",r,n,o,u,t==="update")}})});xe(I);Ie(I);Ze(I);si(I);class ee extends I{constructor(t){const e=j({type:"directed"},t);if("multi"in e&&e.multi!==!1)throw new E("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="directed")throw new E('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class ie extends I{constructor(t){const e=j({type:"undirected"},t);if("multi"in e&&e.multi!==!1)throw new E("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="undirected")throw new E('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class re extends I{constructor(t){const e=j({multi:!0},t);if("multi"in e&&e.multi!==!0)throw new E("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class ne extends I{constructor(t){const e=j({type:"directed",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new E("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="directed")throw new E('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class se extends I{constructor(t){const e=j({type:"undirected",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new E("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="undirected")throw new E('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function ut(s){s.from=function(t,e){const i=j({},t.options,e),r=new s(i);return r.import(t),r}}ut(I);ut(ee);ut(ie);ut(re);ut(ne);ut(se);I.Graph=I;I.DirectedGraph=ee;I.UndirectedGraph=ie;I.MultiGraph=re;I.MultiDirectedGraph=ne;I.MultiUndirectedGraph=se;I.InvalidArgumentsGraphError=E;I.NotFoundGraphError=m;I.UsageGraphError=G;var mt,It;function oe(){return It||(It=1,mt=function(t){return t!==null&&typeof t=="object"&&typeof t.addUndirectedEdgeWithKey=="function"&&typeof t.dropNode=="function"&&typeof t.multi=="boolean"}),mt}var pt={},bt,Ot;function yi(){return Ot||(Ot=1,bt=function(t){return t!==null&&typeof t=="function"&&typeof t.prototype=="object"&&typeof t.prototype.addUndirectedEdgeWithKey=="function"&&typeof t.prototype.dropNode=="function"}),bt}var nt={},zt;function wi(){return zt||(zt=1,nt.addEdge=function(t,e,i,r,n,o){return e?i==null?t.addUndirectedEdge(r,n,o):t.addUndirectedEdgeWithKey(i,r,n,o):i==null?t.addDirectedEdge(r,n,o):t.addDirectedEdgeWithKey(i,r,n,o)},nt.copyEdge=function(t,e,i,r,n,o){return o=Object.assign({},o),e?i==null?t.addUndirectedEdge(r,n,o):t.addUndirectedEdgeWithKey(i,r,n,o):i==null?t.addDirectedEdge(r,n,o):t.addDirectedEdgeWithKey(i,r,n,o)},nt.mergeEdge=function(t,e,i,r,n,o){return e?i==null?t.mergeUndirectedEdge(r,n,o):t.mergeUndirectedEdgeWithKey(i,r,n,o):i==null?t.mergeDirectedEdge(r,n,o):t.mergeDirectedEdgeWithKey(i,r,n,o)},nt.updateEdge=function(t,e,i,r,n,o){return e?i==null?t.updateUndirectedEdge(r,n,o):t.updateUndirectedEdgeWithKey(i,r,n,o):i==null?t.updateDirectedEdge(r,n,o):t.updateDirectedEdgeWithKey(i,r,n,o)}),nt}var st={},Ct;function ae(){if(Ct)return st;Ct=1;var s=/^\s$/,t=/\s*,\s*/,e=/\s*\|\s*/;function i(d){return s.test(d)}function r(d){var a,c,h,f,b=!1,A=!1,$=void 0,S=[],M="";for(h=0,f=d.length;h<f;h++)if(a=d[h],b){if($===void 0&&($=""),!M&&a===","){h--,b=!1;continue}if(!A&&a===M){b=!1;continue}if(a==="\\"){if(h+1<f&&(c=d[h+1],c==="r"||c==="t"||c==="n"||c==="\\")){c==="n"?$+=`
`:c==="t"?$+="	":c==="r"?$+="\r":$+="\\",A=!1,h++;continue}A=!0}else $+=a,A=!1}else{if(i(a))continue;if(a===","){$!==void 0&&(S.push($),$=void 0);continue}a==='"'||a==="'"?M=a:(h--,M=""),b=!0,A=!1}return $!==void 0&&S.push($),S}function n(d,a){return!d||d==="string"?a:d==="boolean"?a==="true":d==="byte"||d==="short"||d==="integer"||d==="long"||d==="float"||d==="double"?+a:a}function o(d,a){if(d.startsWith("list")){var c=d.slice(4),h;return a.length>=2&&a[0]==="["&&a[a.length-1]==="]"?h=r(a.slice(1,-1)):a.includes("|")?h=a.split(e):a.includes(",")?h=a.split(t):h=[a],h.map(function(f){return n(c,f)})}else return n(d,a)}st.parseListPieces=r,st.parseScalarValue=n,st.parseValue=o;var u=/["'<>&\s]/g;return st.sanitizeTagName=function(a){return a.replace(u,"").trim()},st}var Et,Pt;function mi(){if(Pt)return Et;Pt=1;var s=yi(),t=wi().mergeEdge,e=ae(),i=e.parseValue;function r(c){return c!==c}function n(c){var h=c.getAttribute("hex");if(h)return h;var f=c.getAttribute("a"),b=c.getAttribute("r"),A=c.getAttribute("g"),$=c.getAttribute("b");return f?"rgba("+b+","+A+","+$+","+f+")":"rgb("+b+","+A+","+$+")"}function o(c,h){var f=c.getElementsByTagName("viz:"+h)[0];return f||(f=c.getElementsByTagNameNS("viz",h)[0]),f||(f=c.getElementsByTagName(h)[0]),f}function u(c){for(var h={},f,b,A=0,$=c.length;A<$;A++)f=c[A],f.nodeName!=="#text"&&(b=f.textContent.trim(),b&&(h[f.tagName.toLowerCase()]=f.textContent));return h}function d(c){for(var h={},f={},b,A,$,S=0,M=c.length;S<M;S++)b=c[S],$=b.getAttribute("id")||b.getAttribute("for"),h[$]={id:$,type:b.getAttribute("type")||"string",title:r(+$)?$:b.getAttribute("title")||$},A=b.getElementsByTagName("default")[0],A&&(f[h[$].title]=i(h[$].type,A.textContent));return[h,f]}function a(c,h,f,b){var A={},$=f.getAttribute("label"),S=f.getAttribute("weight"),M=f.getAttribute("kind");$&&(A.label=$),S&&(A.weight=+S),M&&(A.kind=M);for(var C=f.getElementsByTagName("attvalue"),W,y,g,w,v,_,L=0,k=C.length;L<k;L++){if(W=C[L],_=W.getAttribute("id")||W.getAttribute("for"),w=W.getAttribute("value"),y=c[_],y)g=y.title,v=y.type;else if(b)g=_,v="string";else throw new Error('graphology-gexf/parser: Found undeclared attribute "'+_+'"');A[g]=i(v,w)}var O;for(O in h)O in A||(A[O]=h[O]);var l=o(f,"color");l&&(A.color=n(l)),l=o(f,"size"),l&&(A.size=+l.getAttribute("value"));var p,x,D;return l=o(f,"position"),l&&(p=l.getAttribute("x"),x=l.getAttribute("y"),D=l.getAttribute("z"),p&&(A.x=+p),x&&(A.y=+x),D&&(A.z=+D)),l=o(f,"shape"),l&&(A.shape=l.getAttribute("value")),l=o(f,"thickness"),l&&(A.thickness=+l.getAttribute("value")),A}return Et=function(h,f){return function(A,$,S){S=S||{};var M=S.addMissingNodes===!0,C=S.allowUndeclaredAttributes===!0,W=S.respectInputGraphType===!0,y,g=$,w,v,_,L,k,O,l,p,x;if(!s(A))throw new Error("graphology-gexf/parser: invalid Graph constructor.");if(typeof $=="string"&&(g=new h().parseFromString($,"application/xml")),!(g instanceof f))throw new Error("graphology-gexf/parser: source should either be a XML document or a string.");var D=g.getElementsByTagName("graph")[0],T=g.getElementsByTagName("meta")[0],P=T&&T.childNodes||[],U=g.getElementsByTagName("node"),N=g.getElementsByTagName("edge"),K=g.getElementsByTagName("attributes"),V=[],Y=[];for(p=0,x=K.length;p<x;p++)w=K[p],w.getAttribute("class")==="node"?V=w.getElementsByTagName("attribute"):w.getAttribute("class")==="edge"&&(Y=w.getElementsByTagName("attribute"));var R=D.getAttribute("defaultedgetype")||"undirected";R==="mutual"&&(R="undirected"),v=d(V);var q=v[0],z=v[1];v=d(Y);var et=v[0],J=v[1],it=N[0]?N[0].getAttribute("type")||R:"mixed",ct=W?{}:{type:it},B=new A(ct),ue=u(P),St=T&&T.getAttribute("lastmodifieddate");for(B.replaceAttributes(ue),St&&B.setAttribute("lastModifiedDate",St),p=0,x=U.length;p<x;p++)w=U[p],B.addNode(w.getAttribute("id"),a(q,z,w,C));for(p=0,x=N.length;p<x;p++){if(w=N[p],k=w.getAttribute("id"),_=w.getAttribute("type")||R,O=w.getAttribute("source"),l=w.getAttribute("target"),L=a(et,J,w,C),_!==B.type&&B.type!=="mixed"){if(W)throw new Error("graphology-gexf/parser: one of the file's edges does not respect the input graph type: "+B.type+".");B=B.copy({type:"mixed"})}if(!B.multi&&(_==="directed"&&B.hasDirectedEdge(O,l)||B.hasUndirectedEdge(O,l))){if(W)throw new Error("graphology-gexf/parser: the file contains parallel edges that the input graph type does not allow.");B=B.copy({multi:!0})}if(y=t(B,_!=="directed",k||null,O,l,L),!M&&(y[2]||y[3]))throw new Error("graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care.")}return B}},Et}var vt,Rt;function bi(){if(Rt)return vt;Rt=1;var s=mi();return vt=s(DOMParser,Document),vt}var At,Wt;function Ei(){if(Wt)return At;Wt=1;var s=oe();return At=function(e){if(!s(e))throw new Error("graphology-utils/infer-type: expecting a valid graphology instance.");var i=e.type;return i!=="mixed"?i:e.directedSize===0&&e.undirectedSize===0||e.directedSize>0&&e.undirectedSize>0?"mixed":e.directedSize>0?"directed":"undirected"},At}var _t,jt;function vi(){if(jt)return _t;jt=1;function s(i){return typeof i!="number"&&!i}function t(i){if(typeof i=="string")return i;if(typeof i=="number")return i+"";if(typeof i=="function")return i();if(i instanceof e)return i.toString();throw Error("Bad Parameter")}function e(i,r){if(!(this instanceof e))return new e;this.name_regex=/[_:A-Za-z][-._:A-Za-z0-9]*/,this.indent=!!i,this.indentString=this.indent&&typeof i=="string"?i:"    ",this.output="",this.stack=[],this.tags=0,this.attributes=0,this.attribute=0,this.texts=0,this.comment=0,this.dtd=0,this.root="",this.pi=0,this.cdata=0,this.started_write=!1,this.writer,this.writer_encoding="UTF-8",typeof r=="function"?this.writer=r:this.writer=function(n,o){this.output+=n}}return e.prototype={toString:function(){return this.flush(),this.output},indenter:function(){if(this.indent){this.write(`
`);for(var i=1;i<this.tags;i++)this.write(this.indentString)}},write:function(){for(var i=0;i<arguments.length;i++)this.writer(arguments[i],this.writer_encoding)},flush:function(){for(var i=this.tags;i>0;i--)this.endElement();this.tags=0},startDocument:function(i,r,n){return this.tags||this.attributes?this:(this.startPI("xml"),this.startAttribute("version"),this.text(typeof i=="string"?i:"1.0"),this.endAttribute(),typeof r=="string"&&(this.startAttribute("encoding"),this.text(r),this.endAttribute(),this.writer_encoding=r),n&&(this.startAttribute("standalone"),this.text("yes"),this.endAttribute()),this.endPI(),this.indent||this.write(`
`),this)},endDocument:function(){return this.attributes&&this.endAttributes(),this},writeElement:function(i,r){return this.startElement(i).text(r).endElement()},writeElementNS:function(i,r,n,o){return o||(o=n),this.startElementNS(i,r,n).text(o).endElement()},startElement:function(i){if(i=t(i),!i.match(this.name_regex)||this.tags===0&&this.root&&this.root!==i)throw Error("Invalid Parameter");return this.attributes&&this.endAttributes(),++this.tags,this.texts=0,this.stack.length>0&&(this.stack[this.stack.length-1].containsTag=!0),this.stack.push({name:i,tags:this.tags}),this.started_write&&this.indenter(),this.write("<",i),this.startAttributes(),this.started_write=!0,this},startElementNS:function(i,r,n){if(i=t(i),r=t(r),!i.match(this.name_regex)||!r.match(this.name_regex))throw Error("Invalid Parameter");return this.attributes&&this.endAttributes(),++this.tags,this.texts=0,this.stack.length>0&&(this.stack[this.stack.length-1].containsTag=!0),this.stack.push({name:i+":"+r,tags:this.tags}),this.started_write&&this.indenter(),this.write("<",i+":"+r),this.startAttributes(),this.started_write=!0,this},endElement:function(){if(!this.tags)return this;var i=this.stack.pop();return this.attributes>0?(this.attribute&&(this.texts&&this.endAttribute(),this.endAttribute()),this.write("/"),this.endAttributes()):(i.containsTag&&this.indenter(),this.write("</",i.name,">")),--this.tags,this.texts=0,this},writeAttribute:function(i,r){return typeof r=="function"&&(r=r()),s(r)?this:this.startAttribute(i).text(r).endAttribute()},writeAttributeNS:function(i,r,n,o){return o||(o=n),typeof o=="function"&&(o=o()),s(o)?this:this.startAttributeNS(i,r,n).text(o).endAttribute()},startAttributes:function(){return this.attributes=1,this},endAttributes:function(){return this.attributes?(this.attribute&&this.endAttribute(),this.attributes=0,this.attribute=0,this.texts=0,this.write(">"),this):this},startAttribute:function(i){if(i=t(i),!i.match(this.name_regex))throw Error("Invalid Parameter");return!this.attributes&&!this.pi?this:this.attribute?this:(this.attribute=1,this.write(" ",i,'="'),this)},startAttributeNS:function(i,r,n){if(i=t(i),r=t(r),!i.match(this.name_regex)||!r.match(this.name_regex))throw Error("Invalid Parameter");return!this.attributes&&!this.pi?this:this.attribute?this:(this.attribute=1,this.write(" ",i+":"+r,'="'),this)},endAttribute:function(){return this.attribute?(this.attribute=0,this.texts=0,this.write('"'),this):this},text:function(i){return i=t(i),!this.tags&&!this.comment&&!this.pi&&!this.cdata?this:this.attributes&&this.attribute?(++this.texts,this.write(i.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;").replace(/\t/g,"&#x9;").replace(/\n/g,"&#xA;").replace(/\r/g,"&#xD;")),this):(this.attributes&&!this.attribute&&this.endAttributes(),this.comment||this.cdata?this.write(i):this.write(i.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")),++this.texts,this.started_write=!0,this)},writeComment:function(i){return this.startComment().text(i).endComment()},startComment:function(){return this.comment?this:(this.attributes&&this.endAttributes(),this.indenter(),this.write("<!--"),this.comment=1,this.started_write=!0,this)},endComment:function(){return this.comment?(this.write("-->"),this.comment=0,this):this},writeDocType:function(i,r,n,o){return this.startDocType(i,r,n,o).endDocType()},startDocType:function(i,r,n,o){if(this.dtd||this.tags)return this;if(i=t(i),r=r&&t(r),n=n&&t(n),o=o&&t(o),!i.match(this.name_regex)||r&&!r.match(/^[\w\-][\w\s\-\/\+\:\.]*/)||n&&!n.match(/^[\w\.][\w\-\/\\\:\.]*/)||o&&!o.match(/[\w\s\<\>\+\.\!\#\-\?\*\,\(\)\|]*/))throw Error("Invalid Parameter");return r=r?' PUBLIC "'+r+'"':n?" SYSTEM":"",n=n?' "'+n+'"':"",o=o?" ["+o+"]":"",this.started_write&&this.indenter(),this.write("<!DOCTYPE ",i,r,n,o),this.root=i,this.dtd=1,this.started_write=!0,this},endDocType:function(){return this.dtd?(this.write(">"),this):this},writePI:function(i,r){return this.startPI(i).text(r).endPI()},startPI:function(i){if(i=t(i),!i.match(this.name_regex))throw Error("Invalid Parameter");return this.pi?this:(this.attributes&&this.endAttributes(),this.started_write&&this.indenter(),this.write("<?",i),this.pi=1,this.started_write=!0,this)},endPI:function(){return this.pi?(this.write("?>"),this.pi=0,this):this},writeCData:function(i){return this.startCData().text(i).endCData()},startCData:function(){return this.cdata?this:(this.attributes&&this.endAttributes(),this.indenter(),this.write("<![CDATA["),this.cdata=1,this.started_write=!0,this)},endCData:function(){return this.cdata?(this.write("]]>"),this.cdata=0,this):this},writeRaw:function(i){return i=t(i),!this.tags&&!this.comment&&!this.pi&&!this.cdata?this:this.attributes&&this.attribute?(++this.texts,this.write(i.replace("&","&amp;").replace('"',"&quot;")),this):(this.attributes&&!this.attribute&&this.endAttributes(),++this.texts,this.write(i),this.started_write=!0,this)}},_t=e,_t}var xt,Ft;function Ai(){return Ft||(Ft=1,xt=vi()),xt}var $t,Kt;function _i(){if(Kt)return $t;Kt=1;var s=oe(),t=Ei(),e=Ai(),i=ae().sanitizeTagName,r=new Set(["color","size","x","y","z","shape","thickness"]),n=/^\s*rgba?\s*\(/i,o=/^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)\s*(?:,\s*([.0-9]*))?\)\s*$/;function u(l){if(!l||typeof l!="string")return{};if(l[0]==="#")return l=l.slice(1),l.length===3?{r:parseInt(l[0]+l[0],16),g:parseInt(l[1]+l[1],16),b:parseInt(l[2]+l[2],16)}:{r:parseInt(l[0]+l[1],16),g:parseInt(l[2]+l[3],16),b:parseInt(l[4]+l[5],16)};if(n.test(l)){var p={};return l=l.match(o),p.r=+l[1],p.g=+l[2],p.b=+l[3],l[4]&&(p.a=+l[4]),p}return{}}function d(l,p,x){var D={},T;for(T in x)T==="label"?D.label=x.label:l==="edge"&&T==="weight"?D.weight=x.weight:l==="edge"&&T==="kind"?D.kind=x.kind:r.has(T)?(D.viz=D.viz||{},D.viz[T]=x[T]):(D.attributes=D.attributes||{},D.attributes[T]=x[T]);return D}var a=d.bind(null,"node"),c=d.bind(null,"edge");function h(l){return l<=2147483647&&l>=-2147483647}function f(l){return typeof l>"u"||l===null||l===""||l!==l}var b={liststring:0,listdouble:1,listlong:2,listinteger:3,listboolean:4,string:5,double:6,long:7,integer:8,boolean:9,empty:10};function A(l){return f(l)?"empty":typeof l=="boolean"?"boolean":typeof l=="object"?"string":typeof l=="number"?l===(l|0)?h(l)?"integer":"long":"double":"string"}function $(l){for(var p="empty",x=b[p],D,T,P,U=0,N=l.length;U<N;U++)D=l[U],T=A(D),P=b[T],P<x&&(p=T,x=P);return p}function S(l){if(l instanceof Set&&(l=Array.from(l)),Array.isArray(l)){var p=$(l);return p==="empty"?"empty":"list"+p}return A(l)}var M=/[\r\t\n]/g,C="'",W='"';function y(l,p){return l!=="string"||M.test(p)||p.includes(C)?JSON.stringify(p):p.includes(W)?C+p+C:p}function g(l,p,x){if(p.startsWith("list")){x instanceof Set&&(x=Array.from(x));var D=Array.isArray(x)?x:[x],T=p.slice(4);return l==="1.3"?"["+D.map(function(P){return y(T,P)}).join(", ")+"]":D.join("|")}return""+x}function w(l,p){var x=new Array(l.order),D=0;return l.forEachNode(function(T,P){var U=p(T,P);U.key=T,x[D++]=U}),x}function v(l,p){var x=new Array(l.size),D=0;return l.forEachEdge(function(T,P,U,N,K,V,Y){var R=p(T,P);R.key=T,R.source=U,R.target=N,R.undirected=Y,x[D++]=R}),x}function _(l){for(var p={},x,D,T,P,U=0,N=l.length;U<N;U++)if(x=l[U].attributes,!!x)for(P in x)D=S(x[P]),D!=="empty"&&(T=p[P],T?D!==T&&b[D]<b[T]&&(p[P]=D):p[P]=D);return p}function L(l,p,x){var D;if(Object.keys(p).length){l.startElement("attributes"),l.writeAttribute("class",x);for(D in p)l.startElement("attribute"),l.writeAttribute("id",D),l.writeAttribute("title",D),l.writeAttribute("type",p[D]),l.endElement();l.endElement()}}function k(l,p,x,D,T){var P=!Object.keys(D).length,U,N,K,V,Y,R,q,z,et,J,it;for(p.startElement(x+"s"),J=0,it=T.length;J<it;J++){if(U=T[J],R=U.attributes,z=U.viz,p.startElement(x),p.writeAttribute("id",U.key),x==="edge"&&(Y=U.undirected?"undirected":"directed",Y!==p.defaultEdgeType&&p.writeAttribute("type",Y),p.writeAttribute("source",U.source),p.writeAttribute("target",U.target),q=U.weight,(typeof q=="number"&&!isNaN(q)||typeof q=="string")&&p.writeAttribute("weight",U.weight),U.kind&&p.writeAttribute("kind",U.kind)),U.label&&p.writeAttribute("label",U.label),!P&&R){p.startElement("attvalues");for(N in D)if(N in R){if(V=R[N],f(V))continue;p.startElement("attvalue"),p.writeAttribute("for",N),p.writeAttribute("value",g(l,D[N],V)),p.endElement()}p.endElement()}if(z){if(z.color){if(p.startElementNS("viz","color"),l==="1.3"&&z.color.startsWith("#"))p.writeAttribute("hex",z.color);else{K=u(z.color);for(et in K)p.writeAttribute(et,K[et])}p.endElement()}z.size!==void 0&&(p.startElementNS("viz","size"),p.writeAttribute("value",z.size),p.endElement()),(z.x!==void 0||z.y!==void 0||z.z!==void 0)&&(p.startElementNS("viz","position"),z.x!==void 0&&p.writeAttribute("x",z.x),z.y!==void 0&&p.writeAttribute("y",z.y),z.z!==void 0&&p.writeAttribute("z",z.z),p.endElement()),z.shape&&(p.startElementNS("viz","shape"),p.writeAttribute("value",z.shape),p.endElement()),z.thickness!==void 0&&(p.startElementNS("viz","thickness"),p.writeAttribute("value",z.thickness),p.endElement())}p.endElement()}p.endElement()}var O={encoding:"UTF-8",version:"1.2",formatNode:a,formatEdge:c};return $t=function(p,x){if(!s(p))throw new Error("graphology-gexf/writer: invalid graphology instance.");x=x||{};var D=x.pretty===!1?!1:"  ",T=x.pedantic===!0,P=x.formatNode||O.formatNode,U=x.formatEdge||O.formatEdge,N=new e(D);N.startDocument("1.0",x.encoding||O.encoding);var K=x.version||O.version;if(K!=="1.2"&&K!=="1.3")throw new Error('graphology-gexf/writer: invalid gexf version "'+K+'". Expecting 1.2 or 1.3.');N.startElement("gexf"),N.writeAttribute("version",K),K==="1.2"?(N.writeAttribute("xmlns","http://www.gexf.net/1.2draft"),N.writeAttribute("xmlns:viz","http:///www.gexf.net/1.1draft/viz")):K==="1.3"&&(N.writeAttribute("xmlns","http://gexf.net/1.3"),N.writeAttribute("xmlns:viz","http://gexf.net/1.3/viz"),N.writeAttribute("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance"),N.writeAttribute("xsi:schemaLocation","http://gexf.net/1.3 http://gexf.net/1.3/gexf.xsd")),N.startElement("meta");var V=p.getAttributes();V.lastModifiedDate&&N.writeAttribute("lastmodifieddate",V.lastModifiedDate);var Y,R;for(var q in V)q!=="lastModifiedDate"&&(T&&q!=="creator"&&q!=="description"&&q!=="keywords"||(Y=i(q),Y&&(R=V[q],(typeof R=="string"||typeof R=="number"||typeof R=="boolean")&&N.writeElement(Y,""+R))));N.endElement(),N.startElement("graph");var z=t(p);N.defaultEdgeType=z==="mixed"?"directed":z,N.writeAttribute("defaultedgetype",N.defaultEdgeType);var et=w(p,P),J=v(p,U),it=_(et);L(N,it,"node");var ct=_(J);return L(N,ct,"edge"),k(K,N,"node",it,et),k(K,N,"edge",ct,J),N.toString()},$t}var Bt;function xi(){return Bt||(Bt=1,pt.parse=bi(),pt.write=_i()),pt}xi();function $i(s){fetch("http://localhost:3000/send",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({keyword:s})}).then(t=>console.log(t)).catch(t=>console.error("Error:",t))}function Gi(){var s;console.log("main aici"),(s=document.getElementById("searchForm"))==null||s.addEventListener("submit",function(t){t.preventDefault();const e=document.getElementById("searchInput").value;$i(e)})}Gi();
